<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atualizador BFMIDI</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; padding: 20px; }
        .box { background: white; padding: 2.5rem; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 100%; max-width: 600px; text-align: center; }
        h1 { color: #111; margin-bottom: 0.5rem; }
        .subtitle { color: #666; margin-bottom: 2rem; font-size: 0.95rem; }
        
        .btn { background: #2563eb; color: white; border: none; padding: 16px; width: 100%; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 16px; margin-top: 15px; transition: all 0.2s; }
        .btn:disabled { background: #e2e8f0; color: #94a3b8; cursor: not-allowed; }
        .btn:hover:not(:disabled) { background: #1d4ed8; }
        .btn.warn { background: #f59e0b; }
        .btn.success { background: #16a34a; }
        
        .log { background: #1e1e1e; color: #4ade80; padding: 15px; border-radius: 10px; text-align: left; font-family: 'SF Mono', monospace; height: 300px; overflow-y: auto; margin-top: 20px; font-size: 11px; line-height: 1.5; white-space: pre-wrap; border: 1px solid #333; }
        
        .file-box { border: 2px dashed #cbd5e1; padding: 30px; border-radius: 12px; margin: 20px 0; cursor: pointer; background: #f8fafc; transition: all 0.2s; }
        .file-box:hover { background: #eff6ff; border-color: #2563eb; }
        
        .status-badge { display: inline-block; padding: 6px 12px; border-radius: 20px; font-size: 13px; font-weight: bold; margin-bottom: 15px; background: #e2e8f0; color: #64748b; }
    </style>
</head>
<body>

    <div class="box">
        <h1>Atualizador BFMIDI</h1>
        <p class="subtitle">Vers√£o Frankenstein (v35.0)</p>

        <div class="file-box" onclick="document.getElementById('file').click()">
            <input type="file" id="file" accept=".bin" style="display: none">
            <div id="file-label">
                <div style="font-size: 24px; margin-bottom: 10px">üìÇ</div>
                Clique para selecionar o ficheiro <b>app.bin</b>
            </div>
        </div>

        <div id="status-area">
            <span id="status-badge" class="status-badge">Aguardar ficheiro...</span>
        </div>

        <button id="btn" class="btn" disabled>Carregue o ficheiro primeiro</button>
        <div id="log" class="log">A aguardar in√≠cio...</div>
    </div>

    <script type="module">
        // Importamos apenas o ESPLoader da vers√£o moderna (0.5.4)
        import { ESPLoader } from 'https://unpkg.com/esptool-js@0.5.4/bundle.js';

        const btn = document.getElementById('btn');
        const logBox = document.getElementById('log');
        const statusBadge = document.getElementById('status-badge');
        let firmwareData = null;
        let expectingReconnect = false;

        // --- CLASSE DE TRANSPORTE MANUAL (Resolve erro 'undefined') ---
        class ManualTransport {
            constructor(device) {
                this.device = device;
                this.tracing = false;
                this.slip_reader_enabled = false;
                this.left_over = new Uint8Array(0);
                this.baudrate = 115200;
            }
            
            // Fun√ß√µes que a biblioteca chama internamente
            get_info() { return "ManualTransport"; }
            async getInfo() { return this.device.getInfo(); }
            async getPid() { return this.device.getInfo().usbProductId; }
            
            async connect(baud = 460800) {
                await this.device.open({ baudRate: baud });
                this.baudrate = baud;
            }
            
            async disconnect() { await this.device.close(); }
            
            async write(data) { 
                const writer = this.device.writable.getWriter();
                await writer.write(data);
                writer.releaseLock();
            }
            
            // Implementa√ß√£o b√°sica de leitura que devolve o Reader para o ESPLoader usar
            // O ESPLoader moderno sabe lidar com WebSerial diretamente
            async read(timeout = 0) { return null; } 
            
            // Sinais de controlo
            async setRTS(state) { await this.device.setSignals({ requestToSend: state }); }
            async setDTR(state) { await this.device.setSignals({ dataTerminalReady: state }); }
            async sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }

        // Terminal Simulado
        const term = {
            clean: () => {},
            writeLine: (d) => { log("LIB: " + d); },
            write: (d) => { }
        };

        function log(msg) {
            logBox.innerHTML += `${msg}\n`;
            logBox.scrollTop = logBox.scrollHeight;
        }

        function setStatus(text, bg, color) {
            statusBadge.innerText = text;
            statusBadge.style.backgroundColor = bg;
            statusBadge.style.color = color;
        }

        document.getElementById('file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                firmwareData = ev.target.result;
                document.getElementById('file-label').innerHTML = `‚úÖ <b>${file.name}</b> pronto!`;
                document.getElementById('file-label').style.color = '#2563eb';
                btn.disabled = false;
                btn.innerText = "PASSO 1: VERIFICAR MODO";
                setStatus("Pronto", "#dbeafe", "#1e40af");
                log(`> Ficheiro carregado. Clique no bot√£o azul.`);
            };
            reader.readAsArrayBuffer(file);
        });

        btn.addEventListener('click', async () => {
            try {
                if (!navigator.serial) throw new Error("Navegador incompat√≠vel.");

                if (expectingReconnect) {
                    log("\n>>> FASE 2: GRAVA√á√ÉO <<<");
                    log("Selecione a porta novamente (agora em Bootloader).");
                } else {
                    log("\n>>> FASE 1: DIAGN√ìSTICO <<<");
                    log("A solicitar porta USB...");
                }

                const device = await navigator.serial.requestPort();
                const info = device.getInfo();
                const pid = info.usbProductId;
                
                log(`> Porta detetada! PID: 0x${pid ? pid.toString(16) : '???'}`);

                // --- PASSO 1: VERIFICAR MODO ---
                // 0x0002 (2) = Bootloader (Bom)
                // Outros = Aplica√ß√£o (Precisa Reset)
                const isBootloader = (pid === 0x0002 || pid === 2);

                if (!isBootloader && !expectingReconnect) {
                    log("\n‚ö†Ô∏è MODO APLICA√á√ÉO DETETADO.");
                    log("> O pedal precisa de ir para modo Bootloader.");
                    log("> A enviar comando de Reset...");
                    
                    setStatus("A Reiniciar...", "#fef3c7", "#92400e");
                    
                    // Reset Manual Seguro
                    await device.open({ baudRate: 1200 });
                    await new Promise(r => setTimeout(r, 100));
                    await device.setSignals({ dataTerminalReady: false, requestToSend: true });
                    await new Promise(r => setTimeout(r, 200));
                    await device.setSignals({ dataTerminalReady: true, requestToSend: false });
                    await device.close();

                    log("\n‚úÖ RESET ENVIADO!");
                    log("1. O pedal vai reiniciar.");
                    log("2. O Mac vai dizer 'Disco Ejetado' (Normal).");
                    log("3. Clique no bot√£o LARANJA para reconectar.");
                    
                    btn.innerText = "üëâ CLIQUE AQUI PARA GRAVAR (PASSO 2)";
                    btn.className = "btn warn";
                    expectingReconnect = true;
                    return; // P√°ra aqui!
                }

                // --- PASSO 2: GRAVA√á√ÉO ---
                log("\n‚úÖ MODO DE GRAVA√á√ÉO CONFIRMADO!");
                setStatus("A Gravar...", "#dcfce7", "#166534");
                
                // Usamos o nosso Transporte Manual "Blindado"
                const transport = new ManualTransport(device);
                // 460800 √© a velocidade que funcionou no log oficial
                const esploader = new ESPLoader(transport, 460800, term);

                btn.disabled = true;
                btn.innerText = "A LIGAR...";
                btn.className = "btn"; 

                log("> A iniciar protocolo (0.5.4 + ManualTransport)...");
                
                // No modo bootloader, usamos 'no_reset' ou 'default' com cautela
                // Como j√° estamos no modo certo, 'no_reset' √© mais seguro
                try {
                    await esploader.main_fn({ mode: 'no_reset' });
                } catch (e) {
                    // Se falhar, tenta default
                    log("> Retrying with default reset...");
                    await esploader.main_fn({ mode: 'default' });
                }
                
                await esploader.flash_id();

                log("> ‚úÖ Chip identificado: " + esploader.chip.CHIP_NAME);
                log("> A iniciar transfer√™ncia...");
                
                btn.innerText = "A GRAVAR...";

                const fileArray = [{ data: firmwareData, address: 0x10000 }];
                
                await esploader.write_flash(
                    fileArray,
                    'keep', 'keep', 'keep', false, true,
                    (fileIndex, written, total) => {
                        const percent = Math.round((written / total) * 100);
                        btn.innerText = `GRAVANDO ${percent}%`;
                        if (percent % 10 === 0) log(`> Progresso: ${percent}%`);
                    }
                );

                log("\n‚úÖ SUCESSO! ATUALIZA√á√ÉO CONCLU√çDA.");
                btn.innerText = "CONCLU√çDO! REINICIE O PEDAL";
                btn.className = "btn success";
                btn.disabled = false;
                setStatus("Sucesso!", "#dcfce7", "#166534");

                // Reset Final
                try {
                    await transport.setDTR(false);
                    await transport.setRTS(true);
                    await new Promise(r => setTimeout(r, 100));
                    await transport.setRTS(false);
                } catch(e) {}
                
                await transport.disconnect();

            } catch (e) {
                console.error(e);
                const msg = e.message || e.toString();
                
                if (msg.includes("NetworkError") || msg.includes("lost") || msg.includes("disconnect")) {
                    if (!expectingReconnect) {
                        log("\n‚ö†Ô∏è O dispositivo desconectou-se.");
                        log("Clique no bot√£o para reconectar.");
                        expectingReconnect = true;
                        btn.innerText = "üëâ CONTINUAR (PASSO 2)";
                        btn.className = "btn warn";
                        btn.disabled = false;
                    } else {
                        log("> Desconex√£o. Tente novamente.");
                        btn.innerText = "TENTAR NOVAMENTE";
                        btn.className = "btn";
                        btn.disabled = false;
                    }
                } else {
                    log(`> ‚ùå ERRO: ${msg}`);
                    btn.innerText = "ERRO - TENTE DE NOVO";
                    btn.className = "btn";
                    btn.disabled = false;
                }
            }
        });
    </script>
</body>
</html>
